## 1、图的存储方式
#### 1.1 邻接矩阵
#### 1.2 邻接表

 邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。
## 2、图的遍历方式
#### 2.1 深度优先遍历

相对于对二叉树的递归遍历，从一个节点出发，一直向一个方向遍历，直到没有连接的节点

典型题目： 找连通块、判断是否有环（如 207 题）等

模板 ： [参考](https://leetcode.cn/discuss/post/3581143/fen-xiang-gun-ti-dan-tu-lun-suan-fa-dfsb-qyux/)

```python
def solve(n: int, edges: List[List[int]]) -> List[int]:
    # 节点编号从 0 到 n-1
    g = [[] for _ in range(n)]
    for x, y in edges:
        g[x].append(y)
        g[y].append(x)  # 无向图

    vis = [False] * n

    def dfs(x: int) -> int:
        vis[x] = True  # 避免重复访问节点
        size = 1
        for y in g[x]:
            if not vis[y]:
                size += dfs(y)
        return size

    # 计算每个连通块的大小
    ans = []
    for i, b in enumerate(vis):
        if not b:  # i 没有访问过
            size = dfs(i)
            ans.append(size)
    return ans
```

eg: [leetcode547](https://leetcode.cn/problems/number-of-provinces/description/)

```python
from typing import List


class Solution:
    def dfs(self, isConnected: List[List[int]], isVisited: List[bool], i: int):
        isVisited[i] = True
        ## 继续对节点i相邻的点进行访问
        for j in range(len(isConnected)):
            if isConnected[i][j] == 1 and isVisited[j] == False:
                self.dfs(isConnected, isVisited, j)

    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        ## 使用一个数组记录是否被遍历过
        isVisited = [False] * 201
        n = len(isConnected)
        ans = 0
        for i in range(n):
            if not isVisited[i]:  ## 没有被访问
                ans += 1
                self.dfs(isConnected, isVisited, i)
        return ans
```
#### 2.2 广度优先遍历（BFS）
**就是从一个节点出发，先遍历这个节点连接的一层节点，存储到一个队列中，然后再遍历这一层节点连接的下一层节点。跟二叉树的层序遍历是一致的**

模板 ： [参考](https://leetcode.cn/discuss/post/3581143/fen-xiang-gun-ti-dan-tu-lun-suan-fa-dfsb-qyux/)


```python
# 计算从 start 到各个节点的最短路长度
# 如果节点不可达，则最短路长度为 -1
# 节点编号从 0 到 n-1，边权均为 1
def bfs(n: int, edges: List[List[int]], start: int) -> List[int]:
    g = [[] for _ in range(n)]
    for x, y in edges:
        g[x].append(y)
        g[y].append(x)  # 无向图

    dis = [-1] * n  # -1 表示尚未访问到
    dis[start] = 0
    q = deque([start])
    while q:
        x = q.popleft()
        for y in g[x]:
            if dis[y] < 0:
                dis[y] = dis[x] + 1
                q.append(y)
    return dis
```
