## 1、图的存储方式
#### 1.1 邻接矩阵
#### 1.2 邻接表

 邻接表 使用 数组 + 链表的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。
## 2、图的遍历方式
#### 2.1 深度优先遍历

相对于对二叉树的递归遍历，从一个节点出发，一直向一个方向遍历，直到没有连接的节点

典型题目： 找连通块、判断是否有环（如 207 题）等

模板 ： [参考](https://leetcode.cn/discuss/post/3581143/fen-xiang-gun-ti-dan-tu-lun-suan-fa-dfsb-qyux/)

```python
def solve(n: int, edges: List[List[int]]) -> List[int]:
    # 节点编号从 0 到 n-1
    g = [[] for _ in range(n)]
    for x, y in edges:
        g[x].append(y)
        g[y].append(x)  # 无向图

    vis = [False] * n

    def dfs(x: int) -> int:
        vis[x] = True  # 避免重复访问节点
        size = 1
        for y in g[x]:
            if not vis[y]:
                size += dfs(y)
        return size

    # 计算每个连通块的大小
    ans = []
    for i, b in enumerate(vis):
        if not b:  # i 没有访问过
            size = dfs(i)
            ans.append(size)
    return ans
```

eg: [leetcode547](https://leetcode.cn/problems/number-of-provinces/description/)

```python
from typing import List


class Solution:
    def dfs(self, isConnected: List[List[int]], isVisited: List[bool], i: int):
        isVisited[i] = True
        ## 继续对节点i相邻的点进行访问
        for j in range(len(isConnected)):
            if isConnected[i][j] == 1 and isVisited[j] == False:
                self.dfs(isConnected, isVisited, j)

    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        ## 使用一个数组记录是否被遍历过
        isVisited = [False] * 201
        n = len(isConnected)
        ans = 0
        for i in range(n):
            if not isVisited[i]:  ## 没有被访问
                ans += 1
                self.dfs(isConnected, isVisited, i)
        return ans
```
#### 2.2 广度优先遍历（BFS）
**就是从一个节点出发，先遍历这个节点连接的一层节点，存储到一个队列中，然后再遍历这一层节点连接的下一层节点。跟二叉树的层序遍历是一致的**

模板 ： [参考](https://leetcode.cn/discuss/post/3581143/fen-xiang-gun-ti-dan-tu-lun-suan-fa-dfsb-qyux/)


```python
# 计算从 start 到各个节点的最短路长度
# 如果节点不可达，则最短路长度为 -1
# 节点编号从 0 到 n-1，边权均为 1
def bfs(n: int, edges: List[List[int]], start: int) -> List[int]:
    g = [[] for _ in range(n)]
    for x, y in edges:
        g[x].append(y)
        g[y].append(x)  # 无向图

    dis = [-1] * n  # -1 表示尚未访问到
    dis[start] = 0
    q = deque([start])
    while q:
        x = q.popleft()
        for y in g[x]:
            if dis[y] < 0:
                dis[y] = dis[x] + 1
                q.append(y)
    return dis
```
## 3、计算联通块的大小
**经典例题** [leetcode2685](https://leetcode.cn/problems/count-the-number-of-complete-components/description/)

```python
from typing import List, Tuple
import math


class Solution:
    def __init__(self) -> None:
        self.path = []
    def DFS(
        self, graph: List[List[int]], isVisited: List[bool], node: int) -> None:
        if isVisited[node]:
            return
        isVisited[node] = True
        self.path.append(node)
        for nextNode in graph[node]:
            if not isVisited[nextNode]:
                self.DFS(graph, isVisited, nextNode)
        return

    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        ##首先它一定是一个连通块
        ##统计每个联通块的节点数量
        graph = [[] for _ in range(n)]
        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)
        isVisited = [False] * n
        blocks = []
        for i in range(n):
            if not isVisited[i]:
                self.DFS(graph, isVisited, i, )
                blocks.append(self.path.copy())
                self.path.clear()
        ###计算每个连通分量存在的边的个数
        sideCount = [0] * len(blocks)
        for b in range(len(blocks)):
            tmp = 0
            for i in blocks[b]:
                tmp += len(graph[i])
            sideCount[b] = tmp // 2
        ### 如果是完全完全联通分量，那么对应的连通块的边的数量应该是C(n,2) n是这个连通块的节点数量
        ans = 0
        for i in range(len(blocks)):
            if sideCount[i] == 0:
                ans += 1
                continue
            if math.comb(len(blocks[i]),2) == sideCount[i]:
                ans += 1
        return ans

#### 可以换一种空间复杂度更低的方法
class Solution2:
    ##只统计连通块点的数量和边的数量
    def __init__(self) -> None:
        self.count = 0
        self.sides = 0
    def DFS(self, graph: List[List[int]], isVisited: List[bool], node: int) -> None:
        if isVisited[node]:
            return
        isVisited[node] = True
        self.count += 1
        self.sides += len(graph[node])
        for nextNode in graph[node]:
            if not isVisited[nextNode]:
                self.DFS(graph, isVisited, nextNode)

    def countCompleteComponents(self, n: int, edges: List[List[int]]) -> int:
        ##首先它一定是一个连通块
        ##统计每个联通块的节点数量
        graph = [[] for _ in range(n)]
        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)
        isVisited = [False] * n
        blocks:List[Tuple[int, int]] = []
        ans = 0
        for i in range(n):
            if not isVisited[i]:
                self.DFS(graph, isVisited, i)
                blocks.append((self.count, self.sides // 2))
                #联通分量节点的个数后面是联通分量的边数
                if self.sides // 2 == math.comb(self.count, 2) or self.count == 1:
                    ans += 1
                self.count = 0
                self.sides = 0
        return ans


if __name__ == "__main__":
    n = 6
    edges = [[0, 1], [0, 2], [1, 2], [3, 4]]
    n = 6
    edges = [[0, 1], [0, 2], [1, 2], [3, 4], [3, 5]]
    a = Solution2()
    print(a.countCompleteComponents(n, edges))

```