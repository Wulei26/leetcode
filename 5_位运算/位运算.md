参考灵神： [从集合论到位运算，常见位运算技巧分类总结！](https://leetcode.cn/discuss/post/3571304/cong-ji-he-lun-dao-wei-yun-suan-chang-ji-enve/)
## 1、利用位运算求集合交并集
集合可以用二进制表示，二进制从低到高第 i 位为 1 表示 i 在集合中，为 0 表示 i 不在集合中。例如集合 {0,2,3} 可以用二进制数 1101(2)表示；反过来，二进制数 1101<sub>(2)</sub>就对应着集合 {0,2,3}。
正式地说，包含**非负整数**的集合 S 可以用如下方式「压缩」成一个数字：
\[
f(S) = \sum_{i \in S} 2^i
\]
例如集合 {0,2,3} 可以压缩成2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>+2<sup>3</sup>=13，也就是二进制数 1101<sub>(2)</sub>
eg:
比如求两个非负集合的交集数量  A = [1,3,5,7,9,11,13] 和 B = [1,2,3,5,7,13,15]
可以将A转化为一个正整数:
<div align = center><img width = '1500' height ='150' src ="Snipaste_2025-08-18_15-26-36.png"/>
</div>
也就是 2<sup>1</sup>+2<sup>3</sup>+2<sup>4</sup>+2<sup>7</sup>+2<sup>9</sup>+2<sup>11</sup>+2<sup>13</sup>
将这个过程转化为代码的操作

```python
    A = [0, 3, 5, 7, 9, 11, 13]
    ans = 0
    for x in A:
        ans = ans | 1 << x
    print(ans)
```

这行代码的意思是将 ans 与 1 << x 的结果进行按位或（OR）操作，并将结果赋值给 p。这里 1 << x 是一个二进制位左移操作，它将数字 1 左移 x 位。例如，如果 x 是 3，则 1 << 3 的结果是二进制的 1000 或者十进制中的 8。
每次循环时，如果 x 对应的位置还没有被标记（即该位置的比特位为 0），那么这一行代码将会把 p 的第 x 个比特位 置为1。这是在为 a 列表中的每个元素创建一个位图表示。
因此集合A转化为正整数为：10922 （ 0b10101010101010）

同理可以将B也转化为一个整数

```python
B = [1, 2, 3, 5, 7, 13, 15]
ans = 0
for i in B:
    ans = ans | 1 << i
print(ans)
```
两个集合的交集可以直接用 & 来计算，因为 & 两个均为1的位置上的比特位置为1，其余则均为0

```python
A = [1, 3, 5, 7, 9, 11, 13]
B = [1, 2, 3, 5, 7, 13, 15]
p = 0
q = 0
for x in A:
    p = p | 1 << x
for y in B:
    q = q | 1 << y
print((p & q).bit_count())
```
输出 5 
两个数的交集数量为5

[leetcode2657](https://leetcode.cn/problems/find-the-prefix-common-array-of-two-arrays/description/)

```python
from typing import List


class Solution:
    def findThePrefixCommonArray(self, A: List[int], B: List[int]) -> List[int]:
        p = q = 0
        ans = []
        for x, y in zip(A, B):
            p = p | 1 << x
            q = q | 1 << y
            ans.append((p & q).bit_count())
        return ans


if __name__ == "__main__":
    A = [1, 3, 2, 4]
    B = [3, 1, 2, 4]
    a = Solution().findThePrefixCommonArray(A, B)
    print(a)
```